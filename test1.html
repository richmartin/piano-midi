<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MIDI Player â€“ Hardware or Browser Synth</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 600px;
      margin: 2rem auto;
      padding: 1rem;
    }
    button, select, input {
      margin: 0.5rem;
      padding: 0.4rem 0.8rem;
    }
  </style>
</head>
<body>
  <h1>ðŸŽµ MIDI Player</h1>

  <div>
    <label for="outputSelect">Output:</label>
    <select id="outputSelect">
      <option value="softsynth">Browser Synth</option>
      <option value="hardware">MIDI Device</option>
    </select>
  </div>

  <div>
    <label for="midiFile">MIDI File:</label>
    <input type="file" id="midiFile" accept=".mid,.midi" />
  </div>

  <div>
    <button id="load">Load</button>
    <button id="play">Play</button>
    <button id="pause">Pause</button>
    <button id="stop">Stop</button>
  </div>

  <pre id="status">Status: Ready</pre>

  <script type="module">
    import { WebMidi } from "https://cdn.jsdelivr.net/npm/webmidi@3.1.8/+esm";
    import { Midi } from "https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/+esm";

    // --- Simple Web Audio Synth Output -----------------------------
    class AudioSynthOutput {
      constructor(context = null) {
        this.context = context || new (window.AudioContext || window.webkitAudioContext)();
        this.voices = new Map();
      }
      _noteToFreq(note) {
        const A4 = 440;
        const map = {
          C: -9, "C#": -8, Db: -8, D: -7, "D#": -6, Eb: -6, E: -5,
          F: -4, "F#": -3, Gb: -3, G: -2, "G#": -1, Ab: -1,
          A: 0, "A#": 1, Bb: 1, B: 2
        };
        const [, letter, accidental, octaveStr] = note.match(/^([A-G])(#|b)?(\d)$/);
        const semis = map[letter + (accidental || "")];
        const octave = parseInt(octaveStr);
        const n = semis + (octave - 4) * 12;
        return A4 * Math.pow(2, n / 12);
      }
      sendNoteOn(note, { velocity = 100 } = {}) {
        const freq = this._noteToFreq(note);
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        osc.type = "sine";
        const vol = velocity / 127 * 0.3;
        gain.gain.setValueAtTime(vol, this.context.currentTime);
        osc.frequency.value = freq;
        osc.connect(gain).connect(this.context.destination);
        osc.start();
        this.voices.set(note, { osc, gain });
      }
      sendNoteOff(note) {
        const v = this.voices.get(note);
        if (!v) return;
        const now = this.context.currentTime;
        v.gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        v.osc.stop(now + 0.1);
        this.voices.delete(note);
      }
    }

    // --- MidiPlayer class ------------------------------------------
    class MidiPlayer {
      constructor(output = null) {
        this.output = output;
        this.events = [];
        this.playing = false;
        this.playhead = 0;
        this.lookahead = 25;
        this.scheduleAhead = 100;
        this.currentlyPlaying = new Set();
        this.startTime = 0;
        this.nextEventIndex = 0;
      }

      async loadArrayBuffer(arrayBuffer) {
        const midi = new Midi(arrayBuffer);
        this.events = [];
        midi.tracks.forEach(track => {
          track.notes.forEach(note => {
            this.events.push({
              type: "noteon",
              time: note.time,
              name: note.name,
              velocity: Math.floor(note.velocity * 127)
            });
            this.events.push({
              type: "noteoff",
              time: note.time + note.duration,
              name: note.name
            });
          });
        });
        this.events.sort((a, b) => a.time - b.time);
        this.playhead = 0;
        this.nextEventIndex = 0;
      }

      play() {
        if (this.playing || !this.output) return;
        this.playing = true;
        this.startTime = performance.now() - this.playhead * 1000;
        this._scheduler();
      }

      pause() {
        if (!this.playing) return;
        this.playing = false;
        this.currentlyPlaying.forEach(n => this.output.sendNoteOff(n));
        this.currentlyPlaying.clear();
        this.playhead = (performance.now() - this.startTime) / 1000;
      }

      stop() {
        this.pause();
        this.jumpTo(0);
      }

      jumpTo(time) {
        this.currentlyPlaying.forEach(n => this.output.sendNoteOff(n));
        this.currentlyPlaying.clear();
        this.playhead = time;
        this.nextEventIndex = this.events.findIndex(e => e.time >= time);
        if (this.nextEventIndex < 0) this.nextEventIndex = this.events.length;
      }

      _scheduler() {
        if (!this.playing) return;
        const now = performance.now();
        const elapsed = (now - this.startTime) / 1000;
        while (
          this.nextEventIndex < this.events.length &&
          this.events[this.nextEventIndex].time < elapsed + this.scheduleAhead / 1000
        ) {
          const e = this.events[this.nextEventIndex];
          const delay = e.time * 1000 + this.startTime - now;
          if (e.type === "noteon") {
            this.currentlyPlaying.add(e.name);
            if (this.output.sendNoteOn)
              this.output.sendNoteOn(e.name, { velocity: e.velocity });
          } else if (e.type === "noteoff") {
            this.currentlyPlaying.delete(e.name);
            if (this.output.sendNoteOff)
              this.output.sendNoteOff(e.name);
          }
          this.nextEventIndex++;
        }
        if (this.nextEventIndex < this.events.length) {
          setTimeout(() => this._scheduler(), this.lookahead);
        } else {
          this.playing = false;
        }
      }
    }

    // --- UI + Wiring -----------------------------------------------
    const statusEl = document.getElementById("status");
    const player = new MidiPlayer();
    let selectedOutput = new AudioSynthOutput();

    document.getElementById("outputSelect").onchange = async e => {
      if (e.target.value === "hardware") {
        await WebMidi.enable();
        const out = WebMidi.outputs[0];
        if (!out) {
          alert("No MIDI output found!");
          e.target.value = "softsynth";
          return;
        }
        selectedOutput = out;
        statusEl.textContent = "Using hardware MIDI output: " + out.name;
      } else {
        selectedOutput = new AudioSynthOutput();
        statusEl.textContent = "Using browser synth output.";
      }
      player.output = selectedOutput;
    };

    // Load button
    document.getElementById("load").onclick = async () => {
      const fileInput = document.getElementById("midiFile");
      let arrayBuffer;
      if (fileInput.files.length) {
        arrayBuffer = await fileInput.files[0].arrayBuffer();
      } else {
        const res = await fetch("https://cdn.jsdelivr.net/gh/gleitz/midi-js-soundfonts/FatBoy/FluidR3_GM/mid/Beethoven_Fur_Elise.mid");
        arrayBuffer = await res.arrayBuffer();
      }
      await player.loadArrayBuffer(arrayBuffer);
      player.output = selectedOutput;
      statusEl.textContent = "Loaded MIDI file (" + player.events.length + " events)";
    };

    document.getElementById("play").onclick = () => {
      selectedOutput.context?.resume?.(); // resume AudioContext if suspended
      player.play();
      statusEl.textContent = "Playing...";
    };
    document.getElementById("pause").onclick = () => {
      player.pause();
      statusEl.textContent = "Paused.";
    };
    document.getElementById("stop").onclick = () => {
      player.stop();
      statusEl.textContent = "Stopped.";
    };
  </script>
</body>
</html>
